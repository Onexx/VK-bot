package model.repository.impl

import model.database.DatabaseUtils
import model.domain.Repeats
import model.domain.Task
import model.repository.TaskRepository
import java.sql.*
import java.time.LocalDate
import java.time.LocalTime
import javax.sql.DataSource

class MariaDbTaskRepositoryImpl(
    private val dataSource: DataSource = DatabaseUtils.getDataSource()
) : TaskRepository {

    override fun create(userId: Int) {
        try {
            dataSource.connection.use { connection ->
                connection.prepareStatement(
                    "INSERT INTO Tasks (authorId, creationFinished) VALUES (?, ?)",
                    Statement.RETURN_GENERATED_KEYS
                ).use { statement ->
                    statement.setInt(1, userId)
                    statement.setBoolean(2, false)

                    if (statement.executeUpdate() != 1) {
                        System.err.println("Couldn't create new task for user $userId: Update unsuccessful")
                    } else {
                        val generatedKeys = statement.generatedKeys
                        if (!generatedKeys.next()) {
                            System.err.println("Couldn't save new task [no autogenerated fields].")
                        }
                    }
                }
            }
        } catch (e: SQLException) {
            System.err.println("Couldn't save new task for user $userId: $e")
        }
    }

    override fun setDate(userId: Int, date: LocalDate) {
        try {
            dataSource.connection.use { connection ->
                connection.prepareStatement(
                    "UPDATE `Tasks` SET `date` = ? WHERE authorId = ? and creationFinished = false"
                ).use { statement ->
                    statement.setDate(1, Date.valueOf(date))
                    statement.setInt(2, userId)

                    if (statement.executeUpdate() != 1) {
                        System.err.println("Couldn't update date for user $userId: Update unsuccessful")
                    }
                }
            }
        } catch (e: SQLException) {
            System.err.println("Couldn't update date for user $userId: $e")
        }
    }

    override fun setTime(userId: Int, time: LocalTime) {
        try {
            dataSource.connection.use { connection ->
                connection.prepareStatement(
                    "UPDATE `Tasks` SET `time` = ? WHERE authorId = ? and creationFinished = false"
                ).use { statement ->
                    statement.setTime(1, Time.valueOf(time))
                    statement.setInt(2, userId)

                    if (statement.executeUpdate() != 1) {
                        System.err.println("Couldn't update time for user $userId: Update unsuccessful")
                    }
                }
            }
        } catch (e: SQLException) {
            System.err.println("Couldn't update time for user $userId: $e")
        }
    }

    override fun setRepeat(userId: Int, repeat: Repeats) {
        try {
            dataSource.connection.use { connection ->
                connection.prepareStatement(
                    "UPDATE `Tasks` SET `repeats` = ? WHERE authorId = ? and creationFinished = false"
                ).use { statement ->
                    statement.setString(1, repeat.name)
                    statement.setInt(2, userId)

                    if (statement.executeUpdate() != 1) {
                        System.err.println("Couldn't update repeat for user $userId: Update unsuccessful")
                    }
                }
            }
        } catch (e: SQLException) {
            System.err.println("Couldn't update repeat for user $userId: $e")
        }
    }

    override fun setText(userId: Int, text: String) {
        try {
            dataSource.connection.use { connection ->
                connection.prepareStatement(
                    "UPDATE `Tasks` SET `text` = ? WHERE authorId = ? and creationFinished = false"
                ).use { statement ->
                    statement.setString(1, text)
                    statement.setInt(2, userId)

                    if (statement.executeUpdate() != 1) {
                        System.err.println("Couldn't update text for user $userId: Update unsuccessful")
                    }
                }
            }
        } catch (e: SQLException) {
            System.err.println("Couldn't update text for user $userId: $e")
        }
    }

    override fun setCreationFinished(userId: Int, creationFinished: Boolean) {
        try {
            dataSource.connection.use { connection ->
                connection.prepareStatement(
                    "UPDATE `Tasks` SET `creationFinished` = ? WHERE authorId = ? and creationFinished = false"
                ).use { statement ->
                    statement.setBoolean(1, creationFinished)
                    statement.setInt(2, userId)

                    if (statement.executeUpdate() != 1) {
                        System.err.println("Couldn't update creationFinished flag for user $userId: Update unsuccessful")
                    }
                }
            }
        } catch (e: SQLException) {
            System.err.println("Couldn't update creationFinished flag for user $userId: $e")
        }
    }

    override fun removeUnfinishedTask(userId: Int) {
        try {
            dataSource.connection.use { connection ->
                connection.prepareStatement(
                    "DELETE FROM `Tasks` WHERE authorId = ? and creationFinished = false"
                ).use { statement ->
                    statement.setInt(1, userId)

                    if (statement.executeUpdate() != 1) {
                        System.err.println("Couldn't remove unfinished task for user $userId: Update unsuccessful")
                    }
                }
            }
        } catch (e: SQLException) {
            System.err.println("Couldn't remove unfinished task for user $userId: $e")
        }
    }

    override fun deleteTaskById(userId: Int, taskId: Long) {
        try {
            dataSource.connection.use { connection ->
                connection.prepareStatement(
                    "DELETE FROM `Tasks` WHERE authorId = ? and id = ? and creationFinished = true"
                ).use { statement ->
                    statement.setInt(1, userId)
                    statement.setLong(2, taskId)

                    if (statement.executeUpdate() != 1) {
                        System.err.println("Couldn't delete task [$taskId] for user $userId: Update unsuccessful")
                    }
                }
            }
        } catch (e: SQLException) {
            System.err.println("Couldn't delete task [$taskId] for user $userId: $e")
        }
    }

    override fun findTasksByAuthorId(authorId: Int): List<Task> {
        try {
            dataSource.connection.use { connection ->
                connection.prepareStatement("SELECT * FROM Tasks WHERE authorId=? and creationFinished = true ORDER BY date, time")
                    .use { statement ->
                        statement.setInt(1, authorId)
                        return statement.executeQuery().use { resultSet ->
                            toTasksList(statement.metaData, resultSet)
                        }
                    }
            }
        } catch (e: SQLException) {
            System.err.println("Couldn't find tasks for user $authorId: $e")
            return emptyList()
        }
    }

    @Throws(SQLException::class)
    private fun toTasksList(metaData: ResultSetMetaData, resultSet: ResultSet): List<Task> {
        val result = ArrayList<Task>()
        while (resultSet.next()) {
            result.add(toTask(metaData, resultSet))
        }
        return result
    }

    override fun findUnfinishedTaskByAuthorId(authorId: Int): Task? {
        try {
            dataSource.connection.use { connection ->
                connection.prepareStatement("SELECT * FROM Tasks WHERE authorId=? and creationFinished = false")
                    .use { statement ->
                        statement.setInt(1, authorId)
                        statement.executeQuery().use { resultSet ->
                            if (!resultSet.next()) {
                                return null
                            }
                            return toTask(statement.metaData, resultSet)
                        }
                    }
            }
        } catch (e: SQLException) {
            System.err.println("Couldn't find tasks for user $authorId: $e")
            return null
        }
    }

    @Throws(SQLException::class)
    private fun toTask(metaData: ResultSetMetaData, resultSet: ResultSet): Task {
        val task = Task()
        for (i in 1..metaData.columnCount) {
            when (metaData.getColumnName(i)) {
                "id" -> task.id = resultSet.getLong(i)
                "authorId" -> task.authorId = resultSet.getInt(i)
                "date" -> task.date = resultSet.getDate(i).toLocalDate()
                "time" -> task.time = resultSet.getTime(i).toLocalTime()
                "repeats" -> task.repeat = Repeats.valueOf(resultSet.getString(i))
                "text" -> task.text = resultSet.getString(i)
                "creationFinished" -> task.creationFinished = resultSet.getBoolean(i)
                else -> {
                }
            }
        }
        return task
    }
}